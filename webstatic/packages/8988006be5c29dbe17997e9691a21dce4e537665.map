)]}'
{"version":3,"file":"/packages/spacebars.js","sources":["spacebars/spacebars-runtime.js","spacebars/dynamic.html","spacebars/dynamic.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iF;AACA,U;AACA,mF;AACA,qD;AACA,sG;AACA,6D;AACA,qG;;AAEA,mB;AACA,qB;AACA,0B;AACA,mC;AACA,G;AACA,yB;AACA,0B;AACA,2C;AACA,G;;AAEA,yC;AACA,4C;;AAEA,gC;;AAEA,uB;AACA,oE;AACA,0B;AACA,yB;AACA,M;AACA,6B;;AAEA,sB;AACA,kB;AACA,+B;AACA,2G;;AAEA,8B;AACA,I;;AAEA,W;AACA,E;;AAEA,+D;AACA,2D;AACA,2B;AACA,E;AACA,oD;AACA,oE;AACA,U;AACA,qD;AACA,uB;AACA,kE;AACA,wB;AACA,wB;AACA,mC;AACA,yC;AACA,0B;AACA,wD;AACA,6B;AACA,mD;AACA,oB;AACA,Y;AACA,yD;AACA,uB;AACA,8B;AACA,2B;AACA,yD;AACA,O;AACA,oD;AACA,K;AACA,G;;AAEA,0C;AACA,E;;AAEA,iD;AACA,6D;;AAEA,6C;AACA,uC;AACA,M;AACA,uE;AACA,kE;AACA,6E;AACA,wE;AACA,E;;AAEA,qD;AACA,6D;;AAEA,wC;AACA,gB;AACA,0C;AACA,kB;AACA,+E;AACA,iB;AACA,qB;AACA,e;AACA,U;AACA,0E;AACA,G;AACA,E;;AAEA,qD;AACA,6D;;AAEA,gB;AACA,E;;AAEA,mC;AACA,E;AACA,mE;AACA,qD;AACA,sC;AACA,yC;AACA,gB;AACA,qC;AACA,iB;AACA,M;AACA,2B;AACA,E;;AAEA,2D;AACA,8D;AACA,iE;AACA,sB;AACA,6C;AACA,oC;AACA,iE;AACA,qB;AACA,gD;AACA,6B;AACA,+D;AACA,K;;AAEA,sC;AACA,U;AACA,6B;AACA,2D;;AAEA,iB;AACA,G;AACA,E;;AAEA,0D;AACA,gC;AACA,gC;AACA,uC;AACA,wC;AACA,kC;;AAEA,yB;AACA,E;;AAEA,sE;AACA,gF;AACA,wC;AACA,+C;AACA,wC;AACA,0C;;AAEA,yC;AACA,E;AACA,iE;;AAEA,6D;AACA,2D;AACA,4D;AACA,4D;AACA,2D;AACA,W;AACA,E;AACA,gE;AACA,qE;AACA,oE;AACA,E;AACA,4D;AACA,E;AACA,qC;AACA,E;AACA,4D;AACA,E;AACA,yC;AACA,E;AACA,8D;AACA,qD;AACA,6B;AACA,mE;AACA,qC;AACA,4B;AACA,mD;AACA,6C;AACA,wE;AACA,qD;AACA,G;;AAEA,kC;AACA,oB;;AAEA,c;AACA,qD;;AAEA,0B;AACA,mC;AACA,kB;AACA,oD;AACA,mE;AACA,mC;AACA,0C;AACA,I;AACA,E;;AAEA,wE;AACA,4B;AACA,qE;AACA,8B;AACA,uB;AACA,qD;AACA,M;AACA,yB;AACA,4E;AACA,M;AACA,gC;AACA,gC;AACA,wB;AACA,0B;AACA,yC;AACA,0B;AACA,a;AACA,S;AACA,oB;AACA,uC;AACA,0B;AACA,Y;AACA,S;AACA,Q;AACA,sB;AACA,e;AACA,Q;AACA,K;AACA,E;;AAEA,2D;AACA,yC;AACA,4B;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;;ACpPA,8C;AACA,kB;AACA,sB;AACA,uB;AACA,2D;AACA,+B;AACA,6D;AACA,0B;AACA,oB;AACA,oG;AACA,2B;AACA,oB;AACA,gE;AACA,c;AACA,0D;AACA,+C;AACA,Q;AACA,4B;AACA,sB;AACA,gF;AACA,kB;AACA,Q;AACA,I;;AAEA,6D;AACA,kB;AACA,sB;AACA,oC;AACA,0F;AACA,0B;AACA,oB;AACA,kD;AACA,sE;AACA,4B;AACA,sB;AACA,mG;AACA,6B;AACA,sB;AACA,2E;AACA,wE;AACA,8B;AACA,wB;AACA,4D;AACA,yB;AACA,kB;AACA,M;AACA,I;;;;;;;;;;;;;;;;;;;AC/CA,oE;AACA,gC;AACA,E;;AAEA,qD;AACA,6B;AACA,E;;AAEA,+C;AACA,kC;AACA,qE;AACA,4C;AACA,G;;AAEA,gC;AACA,2C;AACA,gE;AACA,yB;AACA,K;AACA,K;AACA,E","sourcesContent":["// * `templateOrFunction` - template (component) or function returning a template\n// or null\nSpacebars.include = function (templateOrFunction, contentBlock, elseContentBlock) {\n  if (contentBlock && ! UI.isComponent(contentBlock))\n    throw new Error('Second argument to Spacebars.include must be a template or UI.block if present');\n  if (elseContentBlock && ! UI.isComponent(elseContentBlock))\n    throw new Error('Third argument to Spacebars.include must be a template or UI.block if present');\n\n  var props = null;\n  if (contentBlock) {\n    props = (props || {});\n    props.__content = contentBlock;\n  }\n  if (elseContentBlock) {\n    props = (props || {});\n    props.__elseContent = elseContentBlock;\n  }\n\n  if (UI.isComponent(templateOrFunction))\n    return templateOrFunction.extend(props);\n\n  var func = templateOrFunction;\n\n  var f = function () {\n    var emboxedFunc = UI.namedEmboxValue('Spacebars.include', func);\n    f.stop = function () {\n      emboxedFunc.stop();\n    };\n    var tmpl = emboxedFunc();\n\n    if (tmpl === null)\n      return null;\n    if (! UI.isComponent(tmpl))\n      throw new Error(\"Expected null or template in return value from inclusion function, found: \" + tmpl);\n\n    return tmpl.extend(props);\n  };\n\n  return f;\n};\n\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.\n// If `bar` and `baz` are functions, they are called before\n// `foo` is called on them.\n//\n// This is the shared part of Spacebars.mustache and\n// Spacebars.attrMustache, which differ in how they post-process the\n// result.\nSpacebars.mustacheImpl = function (value/*, args*/) {\n  var args = arguments;\n  // if we have any arguments (pos or kw), add an options argument\n  // if there isn't one.\n  if (args.length > 1) {\n    var kw = args[args.length - 1];\n    if (! (kw instanceof Spacebars.kw)) {\n      kw = Spacebars.kw();\n      // clone arguments into an actual array, then push\n      // the empty kw object.\n      args = Array.prototype.slice.call(arguments);\n      args.push(kw);\n    } else {\n      // For each keyword arg, call it if it's a function\n      var newHash = {};\n      for (var k in kw.hash) {\n        var v = kw.hash[k];\n        newHash[k] = (typeof v === 'function' ? v() : v);\n      }\n      args[args.length - 1] = Spacebars.kw(newHash);\n    }\n  }\n\n  return Spacebars.call.apply(null, args);\n};\n\nSpacebars.mustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result instanceof Spacebars.SafeString)\n    return HTML.Raw(result.toString());\n  else\n    // map `null`, `undefined`, and `false` to null, which is important\n    // so that attributes with nully values are considered absent.\n    // stringify anything else (e.g. strings, booleans, numbers including 0).\n    return (result == null || result === false) ? null : String(result);\n};\n\nSpacebars.attrMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  if (result == null || result === '') {\n    return null;\n  } else if (typeof result === 'object') {\n    return result;\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {\n    var obj = {};\n    obj[result] = '';\n    return obj;\n  } else {\n    throw new Error(\"Expected valid attribute name, '', null, or object\");\n  }\n};\n\nSpacebars.dataMustache = function (value/*, args*/) {\n  var result = Spacebars.mustacheImpl.apply(null, arguments);\n\n  return result;\n};\n\n// Idempotently wrap in `HTML.Raw`.\n//\n// Called on the return value from `Spacebars.mustache` in case the\n// template uses triple-stache (`{{{foo bar baz}}}`).\nSpacebars.makeRaw = function (value) {\n  if (value == null) // null or undefined\n    return null;\n  else if (value instanceof HTML.Raw)\n    return value;\n  else\n    return HTML.Raw(value);\n};\n\n// If `value` is a function, called it on the `args`, after\n// evaluating the args themselves (by calling them if they are\n// functions).  Otherwise, simply return `value` (and assert that\n// there are no args).\nSpacebars.call = function (value/*, args*/) {\n  if (typeof value === 'function') {\n    // evaluate arguments if they are functions (by calling them)\n    var newArgs = [];\n    for (var i = 1; i < arguments.length; i++) {\n      var arg = arguments[i];\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);\n    }\n\n    return value.apply(null, newArgs);\n  } else {\n    if (arguments.length > 1)\n      throw new Error(\"Can't call non-function: \" + value);\n\n    return value;\n  }\n};\n\n// Call this as `Spacebars.kw({ ... })`.  The return value\n// is `instanceof Spacebars.kw`.\nSpacebars.kw = function (hash) {\n  if (! (this instanceof Spacebars.kw))\n    // called without new; call with new\n    return new Spacebars.kw(hash);\n\n  this.hash = hash || {};\n};\n\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {\n  if (! (this instanceof Spacebars.SafeString))\n    // called without new; call with new\n    return new Spacebars.SafeString(html);\n\n  return new Handlebars.SafeString(html);\n};\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;\n\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind\n// of `foo.bar.baz` that allows safe indexing of `null` and\n// indexing of functions (which calls the function).  If the\n// result is a function, it is always a bound function (e.g.\n// a wrapped version of `baz` that always uses `foo.bar` as\n// `this`).\n//\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either\n// a non-function value or a \"fully-bound\" function wrapping a value,\n// where fully-bound means it takes no arguments and ignores `this`.\n//\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:\n//\n// * If `foo` is falsy, return `foo`.\n//\n// * If `foo` is a function, call it (set `foo` to `foo()`).\n//\n// * If `foo` is falsy now, return `foo`.\n//\n// * Return `foo.bar`, binding it to `foo` if it's a function.\nSpacebars.dot = function (value, id1/*, id2, ...*/) {\n  if (arguments.length > 2) {\n    // Note: doing this recursively is probably less efficient than\n    // doing it in an iterative loop.\n    var argsForRecurse = [];\n    argsForRecurse.push(Spacebars.dot(value, id1));\n    argsForRecurse.push.apply(argsForRecurse,\n                              Array.prototype.slice.call(arguments, 2));\n    return Spacebars.dot.apply(null, argsForRecurse);\n  }\n\n  if (typeof value === 'function')\n    value = value();\n\n  if (! value)\n    return value; // falsy, don't index, pass through\n\n  var result = value[id1];\n  if (typeof result !== 'function')\n    return result;\n  // `value[id1]` (or `value()[id1]`) is a function.\n  // Bind it so that when called, `value` will be placed in `this`.\n  return function (/*arguments*/) {\n    return result.apply(value, arguments);\n  };\n};\n\n// Implement Spacebars's #with, which renders its else case (or nothing)\n// if the argument is falsy.\nSpacebars.With = function (argFunc, contentBlock, elseContentBlock) {\n  return UI.Component.extend({\n    init: function () {\n      this.v = UI.emboxValue(argFunc, UI.safeEquals);\n    },\n    render: function () {\n      return UI.If(this.v, UI.With(this.v, contentBlock), elseContentBlock);\n    },\n    materialized: (function () {\n      var f = function (range) {\n        var self = this;\n        if (Deps.active) {\n          Deps.onInvalidate(function () {\n            self.v.stop();\n          });\n        }\n        if (range) {\n          range.removed = function () {\n            self.v.stop();\n          };\n        }\n      };\n      f.isWith = true;\n      return f;\n    })()\n  });\n};\n\nSpacebars.TemplateWith = function (argFunc, contentBlock) {\n  var w = UI.With(argFunc, contentBlock);\n  w.__isTemplateWith = true;\n  return w;\n};\n","\nTemplate.__define__(\"__dynamic\", (function() {\n  var self = this;\n  var template = this;\n  return [ function() {\n    return Spacebars.mustache(self.lookup(\"checkContext\"));\n  }, \"\\n  \", UI.If(function() {\n    return Spacebars.call(self.lookup(\"dataContextPresent\"));\n  }, UI.block(function() {\n    var self = this;\n    return [ \"\\n    \", Spacebars.include(self.lookupTemplate(\"__dynamicWithDataContext\")), \"\\n  \" ];\n  }), UI.block(function() {\n    var self = this;\n    return [ \"\\n    \\n    \", Spacebars.TemplateWith(function() {\n      return {\n        template: Spacebars.call(self.lookup(\"template\")),\n        data: Spacebars.call(self.lookup(\"..\"))\n      };\n    }, UI.block(function() {\n      var self = this;\n      return Spacebars.include(self.lookupTemplate(\"__dynamicWithDataContext\"));\n    })), \"\\n  \" ];\n  })) ];\n}));\n\nTemplate.__define__(\"__dynamicWithDataContext\", (function() {\n  var self = this;\n  var template = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(self.lookup(\"chooseTemplate\"), self.lookup(\"template\"));\n  }, UI.block(function() {\n    var self = this;\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.call(Spacebars.dot(self.lookup(\"..\"), \"data\"));\n    }, UI.block(function() {\n      var self = this;\n      return [ \"    \\n      \", Spacebars.include(self.lookupTemplate(\"..\")), \"           \\n    \" ];\n    }), UI.block(function() {\n      var self = this;\n      return [ \"             \\n      \", Spacebars.TemplateWith(function() {\n        return Spacebars.call(Spacebars.dot(self.lookup(\"..\"), \"data\"));\n      }, UI.block(function() {\n        var self = this;\n        return Spacebars.include(self.lookupTemplate(\"..\"));\n      })), \"   \\n    \" ];\n    })), \"\\n  \" ];\n  }));\n}));\n","Template.__dynamicWithDataContext.chooseTemplate = function (name) {\n  return Template[name] || null;\n};\n\nTemplate.__dynamic.dataContextPresent = function () {\n  return _.has(this, \"data\");\n};\n\nTemplate.__dynamic.checkContext = function () {\n  if (! _.has(this, \"template\")) {\n    throw new Error(\"Must specify name in the 'template' argument \" +\n                    \"to {{> UI.dynamic}}.\");\n  }\n\n  _.each(this, function (v, k) {\n    if (k !== \"template\" && k !== \"data\") {\n      throw new Error(\"Invalid argument to {{> UI.dynamic}}: \" +\n                      k);\n    }\n  });\n};\n"]}